;; -*- mode: lisp; syntax: common-lisp -*-

(in-package :cl-user)

(defpackage :matrix
  (:use :common-lisp :iterate)
  (:export :transpose :multiplication :from-vector :to-vector
	   :inverse-2x2 :inverse-3x3))

(in-package :matrix)

(defun transpose (m)
  (let* ((n (array-dimensions m))
	 (result (make-array (reverse n))))
    (dotimes (i (first n))
      (dotimes (j (second n))
	(setf (aref result j i) (aref m i j))))
    result))

(defun multiplication (m1 m2)
  (let ((n1 (array-dimension m1 0))
	(n (array-dimension m1 1))
	(n2 (array-dimension m2 1)))
    (assert (= n (array-dimension m2 0)) (m1 m2)
	    "The two matrices are incompatible.")
    (let ((result (make-array `(,n1 ,n2))))
      (dotimes (i n1)
	(dotimes (j n2)
	  (setf (aref result i j)
		(iter (for k from 0 below n)
		      (sum (* (aref m1 i k) (aref m2 k j)))))))
      result)))

(defun from-vector (v)
  (make-array (list (length v) 1)
	      :element-type (array-element-type v)
	      :initial-contents (map 'list #'list v)))

(defun to-vector (m)
  (unless (= (array-dimension m 1) 1) (error "This matrix is not a vector."))
  (let ((result (make-array (array-dimension m 0)
			    :element-type (array-element-type m))))
    (dotimes (i (array-dimension m 0))
      (setf (elt result i) (aref m i 0)))
    result))

(defun inverse-2x2 (m)
  (let* ((a (aref m 0 0))
	 (b (aref m 0 1))
	 (c (aref m 1 0))
	 (d (aref m 1 1))
	 (divisor (- (* a d) (* b c))))
    (make-array '(2 2) :initial-contents
		`((,(/ d divisor) ,(/ (- b) divisor))
		  (,(/ (- c) divisor) ,(/ a divisor))))))

(defun inverse-3x3 (m)
  (let ((result (make-array '(3 3)))
	(det (+ (* (aref m 0 0) (- (* (aref m 2 2) (aref m 1 1))
				   (* (aref m 2 1) (aref m 1 2))))
		(- (* (aref m 1 0) (- (* (aref m 2 2) (aref m 0 1))
				      (* (aref m 2 1) (aref m 0 2)))))
		(* (aref m 2 0) (- (* (aref m 1 2) (aref m 0 1))
				   (* (aref m 1 1) (aref m 0 2)))))))
    (macrolet ((store (i j neg a1 a2 b1 b2 c1 c2 d1 d2)
		 `(setf (aref result ,i ,j)
			(/ (- (* (aref m ,a1 ,a2) (aref m ,b1 ,b2))
			      (* (aref m ,c1 ,c2) (aref m ,d1 ,d2)))
			   ,(if neg -1 1) det))))
      (store 0 0 nil 2 2 1 1 2 1 1 2)
      (store 0 1  t  2 2 0 1 2 1 0 2)
      (store 0 2 nil 1 2 0 1 1 1 0 2)
      (store 1 0  t  2 2 1 0 2 0 1 2)
      (store 1 1 nil 2 2 0 0 2 0 0 2)
      (store 1 2  t  1 2 0 0 1 0 0 2)
      (store 2 0 nil 2 1 1 0 2 0 1 1)
      (store 2 1  t  2 1 0 0 2 0 0 1)
      (store 2 2 nil 1 1 0 0 1 0 0 1))
    result))
